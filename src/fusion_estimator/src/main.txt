// C:\Project\Cpp\FusionEstimator\src\main.cpp
#include <iostream>
#include "main.h"
#include "drone_simulator.h"

#ifdef __cplusplus
extern "C" {
#endif
#include "Estimator\EstimatorPortN.h"
#ifdef __cplusplus
}
#endif

int main() {
    if constexpr (LOCAL_SIMULATION) {

        int SensorsNumber = 4;
        double PeriodicTime = 0.003;
        
        // 观测参数设定
        double sensorsParams[SensorsNumber][6] = {\
            {0.0,   0.0,   0.0,   0.01,   0.01,   0.001},\
            {100.0, -50.0, 10.0,  0.03,   0.02,   0.0001},\
            {200.0, 50.0,  -20.0, 0.07,   0.03,   0.00004},\
            {-50.0, 100.0, 5.0,   0.1,    0.05,   0.00001}};
        // 状态空间模型创建
        std::vector<EstimatorPortN*> StateSpaceModel1_Sensors = {};// 容器声明
        // 使用循环初始化每个指针并添加到容器中
        for (int i = 0; i < SensorsNumber; ++i) {
            // 创建并初始化EstimatorPortN指针数组
            EstimatorPortN* StateSpaceModel1_SensorsPtrs = new EstimatorPortN; // 创建新的结构体实例
            StateSpaceModel1_Initialization(StateSpaceModel1_SensorsPtrs);     // 调用初始化函数
            StateSpaceModel1_Sensors.push_back(StateSpaceModel1_SensorsPtrs);  // 将指针添加到容器中
        }
        // 状态空间模型参数赋值
        for (int i = 0; i < SensorsNumber; ++i) {
            StateSpaceModel1_Sensors[i]->Double_Par[0] = sensorsParams[i][0];  // 传感器X位置
            StateSpaceModel1_Sensors[i]->Double_Par[1] = sensorsParams[i][1];  // 传感器Y位置
            StateSpaceModel1_Sensors[i]->Double_Par[2] = sensorsParams[i][2];  // 传感器Z位置
            StateSpaceModel1_Sensors[i]->Double_Par[3] = sensorsParams[i][3];  // 传感器信号延迟
            StateSpaceModel1_Sensors[i]->Double_Par[4] = sensorsParams[i][4];  // 传感器信号周期
            for (int j = 0; j < StateSpaceModel1_Sensors[j]->Nz; ++j) {
                StateSpaceModel1_Sensors[i]->Matrix_R[j*StateSpaceModel1_Sensors[j]->Nz+j] = sensorsParams[i][5];  // 传感器噪声
            }
        }

        // 中间参数初始化
        double ObservastionTemp[StateSpaceModel1_Sensors[0]->Nz];
        double EstimatedStateTemp[StateSpaceModel1_Sensors[0]->Nx] = {100,0,0, 0,0,0, 50,0,0};
        double EstimatedStateTimeStamp = 0;
        double EstimatedStateProb[StateSpaceModel1_Sensors[0]->Nx * StateSpaceModel1_Sensors[0]->Nx];
        for (int i = 0; i < StateSpaceModel1_Sensors[0]->Nx; ++i)
            for (int j = 0; j < StateSpaceModel1_Sensors[0]->Nx; ++j)
                EstimatedStateProb[i*StateSpaceModel1_Sensors[0]->Nx+j] = StateSpaceModel1_Sensors[0]->Matrix_P[i*StateSpaceModel1_Sensors[0]->Nx+j];

        // 无人机位置模拟
        DroneSimulator drone;
        
        // 系统时钟频率仿真：100Hz，模拟10秒，
        for (int SimNumber = 0; SimNumber <= 10/PeriodicTime; SimNumber++) {

            double t = PeriodicTime * SimNumber;

            // 目标真实位置 
            auto pos = drone.get_position(t);
            // std::cout << "\nTime: " << t << std::endl;
            // std::cout << "s\n  True Position:       "
            //           << "  X: " << pos.x << "m "
            //           << "  Y: " << pos.y << "m "
            //           << "  Z: " << pos.z << "m "
            //           << std::endl;
            
            // 获取传感器信号
            auto observations = drone.get_observations(t, StateSpaceModel1_Sensors);

            for (size_t i = 0; i < observations.size(); ++i) {

                StateSpaceModel1_Sensors[i]->CurrentTimestamp = t;
                StateSpaceModel1_Sensors[i]->StateUpdateTimestamp = EstimatedStateTimeStamp;
                
                ObservastionTemp[0] = observations[i].azimuth;
                ObservastionTemp[1] = observations[i].elevation;

                if(ObservastionTemp[0])
                {
                    for (int j = 0; j < StateSpaceModel1_Sensors[i]->Nx; ++j)
                        StateSpaceModel1_Sensors[i]->EstimatedState[j] = EstimatedStateTemp[j];
    
                    for (int j = 0; j < StateSpaceModel1_Sensors[i]->Nx; ++j)
                        for (int k = 0; k < StateSpaceModel1_Sensors[i]->Nx; ++k)
                            StateSpaceModel1_Sensors[i]->Matrix_P[j*StateSpaceModel1_Sensors[i]->Nx+k] = EstimatedStateProb[j*StateSpaceModel1_Sensors[i]->Nx+k];
    
                    StateSpaceModel1_EstimatorPort(ObservastionTemp, t, StateSpaceModel1_Sensors[i]);
                    
                    for (int j = 0; j < StateSpaceModel1_Sensors[i]->Nx; ++j)
                    EstimatedStateTemp[j] = StateSpaceModel1_Sensors[i]->EstimatedState[j];
                    EstimatedStateTimeStamp = t;
                    
                    for (int j = 0; j < StateSpaceModel1_Sensors[i]->Nx; ++j){
                        for (int k = 0; k < StateSpaceModel1_Sensors[i]->Nx; ++k){
                            EstimatedStateProb[j*StateSpaceModel1_Sensors[i]->Nx+k] = StateSpaceModel1_Sensors[i]->Matrix_P[j*StateSpaceModel1_Sensors[i]->Nx+k];
                        }
                    }
                    
                    // std::cout << "  Sensor " << i+1 << ":  "
                    //         << "Azimuth: " << observations[i].azimuth<< " deg "
                    //         << "Elevation: " << observations[i].elevation<< " deg "
                    //         << std::endl;
                    // std::cout << "  Estimated Result " << i+1 << ":  "
                    //         << "  X: " << EstimatedStateTemp[0] << " m  "
                    //         << "  Y: " << EstimatedStateTemp[3] << " m  "
                    //         << "  Z: " << EstimatedStateTemp[6] << " m  "
                    //         << std::endl;
                }
            }
        }
        
        std::cout << " \n \n" << std::endl;
        for (int i = 0; i < SensorsNumber; ++i) {
            StateSpaceModel1_EstimatorPortTermination(StateSpaceModel1_Sensors[i]);  // 调用初始化函数
        }

    }
    else{
        std::cout << "Not programed yet \n" << std::endl;
    }
    
    return 0;
}
